<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Satchel CSV AI</title>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 24px; }
    h1 { font-size: 18px; margin: 0 0 12px; }
    .row { display: flex; gap: 10px; align-items: stretch; }
    textarea { width: 100%; height: 84px; padding: 10px; font-size: 14px; }
    button { padding: 10px 14px; font-size: 14px; cursor: pointer; }
    .panel { margin-top: 14px; padding: 12px; border: 1px solid #ddd; border-radius: 10px; }
    .meta { font-size: 12px; opacity: 0.7; margin-top: 8px; }
    .matches { margin-top: 12px; }
    details { margin-top: 8px; }
    code { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size: 12px; }
  </style>
</head>
<body>
  <h1>Satchel CSV AI (local retrieval + OpenAI answer)</h1>

  <div class="row">
    <textarea id="q" placeholder="Ask something like: “What have I written about gentrification in Field Notes?”"></textarea>
    <button id="ask">Ask</button>
  </div>

  <div class="panel" id="status">Loading CSVs…</div>

  <div class="panel">
    <div><strong>Answer</strong></div>
    <div id="a" style="white-space:pre-wrap; margin-top:10px;"></div>
    <div class="meta" id="meta"></div>

    <div class="matches" id="matches"></div>
  </div>

<script>
  // ---- your CSVs ----
  const blogPostsURL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vThaJ-Q5u7zUSy9DA5oMCUkajzPdkWpECZzQf7SYpi8SvSCqvRgzlQvAUI6xAtaumQEnsaHSbYLkHt_/pub?output=csv';
  const inspoPostsURL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTtF8T2xKCyuDXq1_hyxL0Do2g8wfQ5AtrA-SlKSoUa5TlyuaKgekwK4j4ezU1z8dVjf5P8YYVnoXT9/pub?output=csv';
  const fieldNotesURL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTcOtzV-2ZVl1aaRXhnlXEDNmJ8y1pUArx3qjhV3AR66kKSMtR17702FGlrBdppy0YPI084PxrMu9uL/pub?output=csv';
  const placesURL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vSw2ES5awbVdygDc4yHNxEI5g7-bouiex1QmT4yIA94iNHtzGDRLtTNIP3GOl15myZX9yye8XDyaEXY/pub?output=csv';
  const americanismsURL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vR-tRe4QAkAIideMvvWDNWq2Aj_Nx6m4QG9snhFkpqqOGX8gU09X6uUQdkfuOj9yLIybn0iPIFoZbK-/pub?output=csv';
  const objectsURL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vRPknkbhkxJidsCcMnFmvdB2gKx4miqtuECGc5udX7hEAY9IQeTCpNDGMkh31uGuSS1NcODADU_jcRT/pub?output=csv';
  const articlesURL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTo8ua4UreD9MUP4CI6OOXkt8LeagGX9w85veJfgi9DKJnHc2-dbCMvq5cx8DtlUO0YcV5RMPzcJ_KG/pub?output=csv';
  const picturesURL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQ5j1OVFnwB19xVA3ZVM46C8tNKvGHimyElwIAgMFDzurSEFA0m_8iHBIvD1_TKbtlfWw2MaDAirm47/pub?output=csv';
  const photographersListURL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vR4UTNOg8d2LIrCU8A9ebfkYOMV2V3E7egroQgliVc4v6mp7Xi9fdmPaxN3k3YUmeW123C8UvwdiNmy/pub?output=csv';

  // IMPORTANT: set this to your Worker URL after deploy (example below)
  const API_URL = "https://YOUR-WORKER.SUBDOMAIN.workers.dev/ask";

  const SOURCES = [
    { name: "blogPosts", url: blogPostsURL },
    { name: "inspoPosts", url: inspoPostsURL },
    { name: "fieldNotes", url: fieldNotesURL },
    { name: "places", url: placesURL },
    { name: "americanisms", url: americanismsURL },
    { name: "objects", url: objectsURL },
    { name: "articles", url: articlesURL },
    { name: "pictures", url: picturesURL },
    { name: "photographersList", url: photographersListURL },
  ];

  const statusEl = document.getElementById("status");
  const aEl = document.getElementById("a");
  const metaEl = document.getElementById("meta");
  const matchesEl = document.getElementById("matches");
  const qEl = document.getElementById("q");
  const askBtn = document.getElementById("ask");

  // Flattened index of rows from all CSVs:
  // { source, rowIndex, fields, text }
  let INDEX = [];

  function normalize(s) {
    return (s ?? "")
      .toString()
      .toLowerCase()
      .replace(/\s+/g, " ")
      .trim();
  }

  function tokenize(s) {
    return normalize(s)
      .split(/[^a-z0-9]+/g)
      .filter(t => t && t.length > 1);
  }

  function rowToText(rowObj) {
    // Convert any row into a searchable string: "key: value | key: value..."
    return Object.entries(rowObj)
      .map(([k, v]) => `${k}: ${String(v ?? "").trim()}`)
      .join(" | ");
  }

  function loadCSV({ name, url }) {
    return new Promise((resolve, reject) => {
      Papa.parse(url, {
        download: true,
        header: true,
        skipEmptyLines: true,
        complete: (results) => {
          const data = results.data || [];
          // Build entries
          const entries = data.map((row, i) => {
            const text = rowToText(row);
            return { source: name, rowIndex: i + 1, fields: row, text, textNorm: normalize(text) };
          });
          resolve({ name, count: entries.length, entries });
        },
        error: reject
      });
    });
  }

  function scoreEntry(queryTokens, entry) {
    // Simple lexical scoring: count token hits + bonus for exact phrase match
    let score = 0;
    for (const t of queryTokens) {
      if (entry.textNorm.includes(t)) score += 1;
    }
    const qNorm = queryTokens.join(" ");
    if (qNorm.length > 4 && entry.textNorm.includes(qNorm)) score += 3;
    return score;
  }

  function retrieveTopK(question, k = 10) {
    const toks = tokenize(question);
    const scored = INDEX
      .map(e => ({ ...e, score: scoreEntry(toks, e) }))
      .filter(e => e.score > 0)
      .sort((a, b) => b.score - a.score)
      .slice(0, k);

    return scored;
  }

  function buildContext(topMatches) {
    // Keep it compact: include source + row + a trimmed text chunk
    const maxCharsPer = 900; // tweak
    return topMatches.map(m => {
      const snippet = m.text.length > maxCharsPer ? (m.text.slice(0, maxCharsPer) + "…") : m.text;
      return `SOURCE: ${m.source} | ROW: ${m.rowIndex}\n${snippet}`;
    }).join("\n\n---\n\n");
  }

  function renderMatches(topMatches) {
    if (!topMatches.length) {
      matchesEl.innerHTML = `<div class="meta">No matches found in your CSVs (try different keywords).</div>`;
      return;
    }
    const html = topMatches.map(m => {
      const safe = (s) => String(s).replace(/[&<>"]/g, c => ({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;" }[c]));
      return `
        <details>
          <summary><strong>${safe(m.source)}</strong> — row ${m.rowIndex} (score ${m.score})</summary>
          <div style="margin-top:8px;"><code>${safe(m.text)}</code></div>
        </details>
      `;
    }).join("");
    matchesEl.innerHTML = `<div class="meta"><strong>Top matches sent to the model</strong> (expand to inspect)</div>${html}`;
  }

  async function ask() {
    const question = qEl.value.trim();
    aEl.textContent = "";
    metaEl.textContent = "";
    matchesEl.innerHTML = "";

    if (!question) return;

    // Local retrieval
    const topMatches = retrieveTopK(question, 10);
    renderMatches(topMatches);

    const context = buildContext(topMatches);

    // Call your backend relay
    statusEl.textContent = "Thinking…";
    try {
      const res = await fetch(API_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          question,
          context,
          topMatches: topMatches.map(m => ({ source: m.source, rowIndex: m.rowIndex, score: m.score }))
        })
      });

      const data = await res.json();
      if (!res.ok) throw new Error(data?.error || `HTTP ${res.status}`);

      aEl.textContent = data.answer || "(no answer)";
      metaEl.textContent = `Used ${topMatches.length} matches • Model: ${data.model || "unknown"}`;
      statusEl.textContent = "Ready.";
    } catch (err) {
      statusEl.textContent = "Error.";
      aEl.textContent = String(err?.message || err);
    }
  }

  askBtn.addEventListener("click", ask);
  qEl.addEventListener("keydown", (e) => {
    if ((e.ctrlKey || e.metaKey) && e.key === "Enter") ask();
  });

  // Boot: load all CSVs
  (async () => {
    try {
      const results = await Promise.all(SOURCES.map(loadCSV));
      INDEX = results.flatMap(r => r.entries);
      const bySource = results.map(r => `${r.name}: ${r.count}`).join(" • ");
      statusEl.textContent = `Loaded ${INDEX.length} rows total. (${bySource})`;
    } catch (e) {
      statusEl.textContent = `Failed to load CSVs: ${e.message || e}`;
    }
  })();
</script>
</body>
</html>
